{%    from 'macros.md.j2' import apply_alphabetical_ordering_by_brk_descriptions
%}{%  from 'macros.md.j2' import apply_alphabetical_ordering_by_descriptions
%}{%  from 'macros.md.j2' import format_breaking_changes_description, format_commit_summary_line
%}{#
EXAMPLE:

### Features

- Add new feature ([#10](https://domain.com/namespace/repo/pull/10),
  [`abcdef0`](https://domain.com/namespace/repo/commit/HASH))

- **scope**: Add new feature ([`abcdef0`](https://domain.com/namespace/repo/commit/HASH))

### Bug Fixes

- Fix bug ([#11](https://domain.com/namespace/repo/pull/11),
  [`abcdef1`](https://domain.com/namespace/repo/commit/HASH))

### BREAKING CHANGES

- With the change _____, the change causes ___ effect. Ultimately, this section
  it is a more detailed description of the breaking change. With an optional
  scope prefix like the commit messages above.

- **scope**: this breaking change has a scope to identify the part of the code that
  this breaking change applies to for better context.

#}{%  set max_line_width = max_line_width | default(100)
%}{%  set hanging_indent = hanging_indent | default(2)
%}{# Build a dictionary to map group types (e.g. Features) to formatted commit strings #}
{% set group_table = namespace(columns=[]) %}

{# Gather commit descriptions grouped by type #}
{% for type_, commits in commit_objects if type_ != "unknown" %}
  {% set ns = namespace(commits=commits) %}
  {{ apply_alphabetical_ordering_by_descriptions(ns) | default("", true) }}
  {% set commit_descriptions = [] %}
  {% for commit in ns.commits %}
    {% set description = format_commit_summary_line(commit) %}
    {% if commit.descriptions | length > 1 %}
      {% set description = description ~ "<br><br>" ~ commit.descriptions[1:] | join("<br><br>") %}
    {% endif %}
    {% set description = description | autofit_text_width(max_line_width, hanging_indent) %}
    {{ commit_descriptions.append(description) | default("", true) }}
  {% endfor %}
  {{ group_table.columns.append((type_ | title, commit_descriptions | unique)) | default("", true) }}
{% endfor %}

{# Convert commit group tuples into a dict: { group_name: [commit1, commit2, ...] } #}
{% set groups_dict = dict() %}
{% for type_, commits in commit_objects if type_ != "unknown" %}
  {% set ns = namespace(commits=commits) %}
  {{ apply_alphabetical_ordering_by_descriptions(ns) | default("", true) }}
  {% set commit_descriptions = [] %}
  {% for commit in ns.commits %}
    {% set description = format_commit_summary_line(commit) %}
    {% if commit.descriptions | length > 1 %}
      {% set description = description ~ "<br><br>" ~ (commit.descriptions[1:] | join("<br><br>")) %}
    {% endif %}
    {% set description = description | autofit_text_width(max_line_width, hanging_indent) %}
    {{ commit_descriptions.append(description) | default("", true) }}
  {% endfor %}
  {% set _ = groups_dict.update({ (type_ | title): commit_descriptions | list }) %}
{% endfor %}

{# Get group names and list of lists of descriptions #}
{% set group_names = groups_dict.keys() | list %}
{% set group_values = group_names | map('attribute', groups_dict) | map('list') | list %}

{# Get the maximum number of rows needed for the table #}
{% set max_rows = group_values | map('length') | list | max %}

{# Render table header #}
| {% for name in group_names %}{{ name }} |{% endfor %}
| {% for _ in group_names %}--- |{% endfor %}

{# Render each row of commits #}
{% for i in range(0, max_rows) %}
| {% for name in group_names %}
  {{ groups_dict[name][i] if i < (groups_dict[name] | length) else "" }} |
{% endfor %}
{% endfor %}
{#
      # Determine if there are any breaking change commits by filtering the list by breaking descriptions
      # commit_objects is a list of tuples [("Features", [ParsedCommit(), ...]), ("Bug Fixes", [ParsedCommit(), ...])]
      # HOW: Filter out breaking change commits that have no breaking descriptions
      #  1. Re-map the list to only the list of commits under the breaking category from the list of tuples
      #  2. Peel off the outer list to get a list of ParsedCommit objects
      #  3. Filter the list of ParsedCommits to only those with a breaking description
#}{%  set breaking_commits = commit_objects | map(attribute="1.0")
%}{%  set breaking_commits = breaking_commits | rejectattr("error", "defined") | selectattr("breaking_descriptions.0") | list
%}{#
#}{%  if breaking_commits | length > 0
%}{#    PREPROCESS COMMITS
#}{%    set brk_ns = namespace(commits=breaking_commits)
%}{{    apply_alphabetical_ordering_by_brk_descriptions(brk_ns) | default("", true)
}}{#
#}{%    set brking_descriptions = []
%}{#
#}{%    for commit in brk_ns.commits
%}{%      set full_description = "- %s" | format(
            format_breaking_changes_description(commit).split("\n\n") | join("\n\n- ")
          )
%}{{      brking_descriptions.append(
            full_description | autofit_text_width(max_line_width, hanging_indent)
          ) | default("", true)
}}{%    endfor
%}{#
   #    # PRINT BREAKING CHANGE DESCRIPTIONS (header & descriptions)
#}{{    "\n"
}}{{    "### BREAKING CHANGES\n"
}}{{
        "\n%s\n" | format(brking_descriptions | unique | join("\n\n"))
}}{#
#}{%  endif
%}
